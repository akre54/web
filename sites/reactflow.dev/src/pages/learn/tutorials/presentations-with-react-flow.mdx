---
title: 'Creating presentations with React Flow'
intro: ''
date: 2024/01/07
authors: ['hayleigh']
tags: ['react-flow', 'presentation', 'slide-show']
image: /img/tutorials/mindmap/mindmap.png
---

import { Cards, Card, Callout, Tab, Tabs } from 'nextra/components';
import { Bleed } from 'nextra-theme-docs';
import { Image } from 'xy-shared';
import { BlogExampleViewer } from '@/components/example-viewer/blog-embed';
import { TutorialLayout } from '@/layouts/tutorial-with-frontmatter';

<TutorialLayout>
We recently published the results of our 2023 end of year survey. Alongside the
full write up of the results, we also created an [interactive presentation](/developer-survey-2023)
of the key findings using React Flow itself.

A lot of our docs and examples focus on using React Flow in interactive flows
that have dynamic nodes and edges. An interesting discovery from our survey was
the number of folks using React Flow in more static ways, such as visualising
static data! Since we went through the process of creating a presentation with
React Flow ourselves, we thought it would be a great opportunity to share what
we learned!

We'll be building a modified version of the presentation we created with support
for markdown slides and keyboard navigation. Here's a peek at the final result:

<Bleed>
  <BlogExampleViewer
    style={{ aspectRatio: '16 / 9' }}
    codePath="blog-flows/presentation/App"
    additionalFiles={['Slide.tsx', 'slides.ts', 'index.css']}
    dependencies={{ 'react-remark': '2.1.0' }}
    showEditor={false}
    isTypescript
  />
</Bleed>

## Setting up the project

We always recommend using [Vite](https://vitejs.dev) when starting new React Flow
projects and this time we'll use TypeScript too. You can scaffold a new project
with the following command:

```bash
npm create vite@latest -- --template react-ts
```

If you'd prefer to follow along with JavaScript feel free to use the `react`
template instead. You can also follow along in your browser by using our codesandbox
templates:

<Cards num={2}>
  <Card
    title="new.reactflow.dev/js"
    href="https://new.reactflow.dev/js"
    icon={
      <div className="rounded-full w-10 h-10 bg-yellow-200 text-gray-700 font-black flex items-center justify-center">
        JS
      </div>
    }
  />
  <Card
    title="new.reactflow.dev/ts"
    href="https://new.reactflow.dev/ts"
    icon={
      <div className="rounded-full w-10 h-10 bg-blue-500 text-white font-black flex items-center justify-center">
        TS
      </div>
    }
  />
</Cards>

Besides React Flow we only need to pull in one dependency, [`react-remark`](https://www.npmjs.com/package/react-remark),
to help us render markdown in our slides.

```bash
npm install reactflow react-remark
```

We'll modify the generated `main.tsx` to include React Flow's styles, as well as
wrap the app in a `<ReactFlowProvider />` to make sure we can access the React Flow
instance in our components;

```tsx filename="main.tsx" {3,7,12-14}
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from 'reactflow';

import App from './App';

import 'reactflow/dist/style.css';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ReactFlowProvider>
      <App />
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

For this tutorial we're going to skip over styling, but each example is styled
by vanilla CSS and imported into `main.tsx` to be bundled by vite. If you are
going to style your app differently, for example with [Styled Components](/examples/styling/styled-components) or
[Tailwind CSS](/examples/styling/tailwind) you can skip the import to `index.css`.

Let's also create a new file `Slide.tsx` that will be our custom node used to
render each slide.

```tsx filename="Slide.tsx"
import { type NodeProps } from 'reactflow';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideData = {};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideData>) {
  return (
    <article className="slide nodrag" style={style}>
      <div>Hello, React Flow!</div>
    </article>
  );
}
```

We're setting the slide width and height as constants here (rather than styling
the node in CSS) because we'll want access to those dimensions later on. We've
also stubbed out the `SlideData` type so we can properly type the component's
props.

The last thing to do is to register our new custom node and show something on the
screen.

```tsx filename="App.tsx"
import ReactFlow from 'reactflow';
import { Slide } from './Slide';

const nodeTypes = {
  slide: Slide,
};

export default function App() {
  const nodes = [
    { id: '0', type: 'slide', position: { x: 0, y: 0 }, data: {} },
  ];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView />;
}
```

<Callout>
  It's important to remember to define your `nodeTypes` object _outside_ of the
  component (or to use React's `useMemo` hook)! When the `nodeTypes` object changes,
  the entire flow is re-rendered.
</Callout>

OK, what do we have so far?

<Bleed>
  <BlogExampleViewer
    style={{ aspectRatio: '16 / 9' }}
    codePath="blog-flows/presentation/Scaffold"
    additionalFiles={['Slide.tsx', 'index.css']}
    dependencies={{ 'react-remark': '2.1.0' }}
    showEditor={false}
    isTypescript
  />
</Bleed>

Not super exciting, let's add markdown rendering and create a few slides
side by side!

## Rendering markdown

This step is super simple thank's to the `react-remark` package we installed
earlier. We can use the `<Remark />` component to render a string of markdown
content into our slides.

```tsx filename="Slide.tsx" {2,7-9,19}
import { type NodeProps } from 'reactflow';
import { Remark } from 'react-remark';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideData = {
  source: string;
};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideData>) {
  return (
    <article className="slide nodrag" style={style}>
      <Remark>{data.source}</Remark>
    </article>
  );
}
```

In React Flow, nodes can have data stored on them that can be used during rendering.
In this case we're storing the markdown content to display by adding a `source`
property to the `SlideData` type and passing that to the `<Remark />` component.
We can update our hardcoded nodes with some markdown content to see it in action:

```tsx filename="App.tsx" {2, 5-9}
import ReactFlow from 'reactflow';
import { Slide, SLIDE_WIDTH } from './Slide';

export default function App() {
  const nodes = [
    { id: '0', type: 'slide', position: { x: 0, y: 0 }, data: { source: '# Hello, React Flow!' } },
    { id: '1', type: 'slide', position: { x: SLIDE_WIDTH, y: 0 }, data: { source: '...' } },
    { id: '2', type: 'slide', position: { x: SLIDE_WIDTH * 2, y: 0 }, data: { source: '...' } },
  ];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView />;
}
```

<Bleed>
  <BlogExampleViewer
    style={{ aspectRatio: '16 / 9' }}
    codePath="blog-flows/presentation/RenderingMarkdown"
    additionalFiles={['Slide.tsx', 'index.css']}
    dependencies={{ 'react-remark': '2.1.0' }}
    showEditor={false}
    isTypescript
  />
</Bleed>

You might have noticed that we also imported `SLIDE_WIDTH` to help us position
the additional slides. In the follwing section we'll take a look at how to lay
out those slides automatically...

## Laying out the nodes

We often get asked how to automatically lay out nodes in a flow, and we have some
documentation on how to use common layouting libraries like dagre and d3-hierarchy
in our [layouting guide](/learn/layouting/layouting). It's also totally possible
to write your own layouting algorithm too!

For our presentation app we'll construct a simple grid layout by starting from
0,0 and updating the x or y coordinates any time we have a new slide to the left,
right, up, or down. This part of the guide get's a bit nerdy, but stick with us!

First, we need to update our `SlideData` type to include optional ids for the slides
to the left, right, up, and down of the current slide.

```tsx filename="Slide.tsx" {3-6}
export type SlideData = {
  source: string;
  left?: string;
  up?: string;
  down?: string;
  right?: string;
};
```

By storing this information on the node data directly, we can write fully declarative
slides without worrying about seting up the nodes and edges. Instead this lets us
easily compute the layout of the presentation and we add things like navigation
buttons to each slide to move between them in a later step.

Next we will create a function, `slidesToElements`, that takes an object of slides
and an id for the first slide in the presentation, and returns an array of nodes
and edges that we can pass to the `<ReactFlow />` component.

The algorithm will go something like this:

- Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.
- While that stack is not empty...
  - Pop the current position and slide id off the stack.
  - Look up the slide data by id.
  - Push a new node onto the nodes array with the current id, position, and slide
    data.
  - Add the slide's id to a set of visited slides.
  - For every direction (left, right, up, down)...
    - Make sure the slide has not already been visited.
    - Take the current position and update the x or y coordinate by adding or
      subtracting `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.
    - Push the new position and the new slide's id onto a stack.
    - Push a new edge onto the edges array connecting the current slide to the
      new slide.
    - Repeat for the remaining directions.

If all goes to plan, we should be able to take a stack of slides shown below and
turn them into a neatly laid out grid!

<Image
  src="/img/tutorials/presentation/ideal-layout.png"
  wide
/>

Let's see the code. In a file called `slides.ts` add the following:

```tsx filename="slides.ts"
import { SlideData, SLIDE_WIDTH, SLIDE_HEIGHT } from './Slide'

export const slidesToElements = (initial: string, slides: Record<string, SlideData>) => {
  const visited = new Set()
  const nodes = []
  const edges = []

  // push the initial slide's id and the position { x: 0, y: 0 } onto a stack.
  const stack = [{ id: start, position: { x: 0, y: 0 }}]

  // while that stack is not empty...
  while (stack.length) {
    // pop the current position and slide id off the stack.
    const { id, position } = stack.pop()
    // look up the slide data by id.
    const data = slides[id]
    // remember to add `type: 'slide'` to the node!
    const node = { id, type: 'slide', position, data }

    // push a new node onto the nodes array with the current id, position, and
    // slide data.
    nodes.push(node)
    // add the slide's id to a set of visited slides.
    visited.add(id)

    // for every direction (left, right, up, down)...
    // make sure the slide has not already been visited.
    if (data.left && !visited.has(data.left)) {
      // take the current position and update the x or y coordinate by adding or
      // subtracting `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.
      const nextPosition = {
        x: position.x - SLIDE_WIDTH,
        y: position.y,
      }

      // push the new position and the new slide's id onto a stack.
      stack.push({ id: data.left, position: nextPosition })

      // push a new edge onto the edges array connecting the current slide to the
      // new slide.
      edges.push({ id: `${id}->${data.left}`, source: id, target: data.left });
    }

    // repeat for the remaining directions...
  }

  return { nodes, edges }
}
```

Comments have been added to show which parts of the code correspond to the algorithm
we outlined above. We've left out the code for the right, up, and down directions
for brevity, but the logic is the same for each direction.

Below is a demo app of the layouting algorithm: you can edit the `slides` object
to see how adding slides to different directions affects the layout. Keep in mind
there are two important limitations of this algorithm:

1. It is possible to construct a layout that overlaps two slides in the same
   position.

2. The algorithm will ignore nodes that cannot be reached from the initial slide.

Addressing these shortcomings is totally possible, but a bit beyond the scope of
this tutorial. If you give a shot please share your solution with us on the
[discord server](https://discord.com/invite/RVmnytFmGW)!

<Bleed>
  <BlogExampleViewer
    style={{ aspectRatio: '16 / 9' }}
    codePath="blog-flows/presentation/LayoutDemo"
    additionalFiles={[ 'Flow.tsx','index.css']}
    showEditor
    isTypescript
  />
</Bleed>

With our layouting algorithm in place, we can swap out our hardcoded nodes array
and create an object of slides that we can pass to `slidesToElements` instead.

```tsx filename="slides.ts"
export const slides = {
  '01': {
    source: `...`,
    right: '02',
  },
  '02': {
    source: `...`,
    left: '01',
    up: '03',
    right: '04',
  },
  '03': {
    source: `...`,
    down: '02',
  },
  '04': {
    source: `...`,
    left: '02',
  }
} as Record<string, SlideData>
```

Then in `App.tsx` we can replace the old nodes array:

```tsx filename="App.tsx" {1,4,7-8, }
import { useMemo } from 'react'
import ReactFlow from 'reactflow';
import { Slide } from './Slide';
import { slides, slidesToElements } from './slides'

export default function App() {
  const start = '01'
  const { nodes, edges } = useMemo(() => slidesToElements(start, slides), [])

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} edges={edges} fitView />;
}
```

The nodes and edges in our flow are static, so we can use `useMemo` to memoize
the layouting computation.

## Navigating between slides

So far we have our presentation laid out in a grid, but we have to manually pan
the canvas to see each slide which isn't very practical for a presentation! We're
going to add three different ways to navigate around our presentation:

- Click-to-focus on nodes. This will allow us to jump around to different slides
  by clicking on them.

- Navigation buttons on each slide. These will allow us to move sequentially
  between slides in any valid direction.

- Keyboard navigation as an extension to navigation controls to move between
  slides with the arrow keys.

### Focus on click

The `<ReactFlow />` element can receive an [`onNodeClick`](/api-reference/react-flow#on-node-click)
callback that fires when _any_ node is clicked. Along with the mouse event itself,
we also receive a reference to the node that was clicked on, and we can use that
to pan the canvas thanks to the `fitView` method.

[`fitView`](/api-reference/react-flow-instance#fit-view) is a method on the React
Flow instance, and we can get access to it by using the [`useReactFlow`](/api-reference/react-flow-instance#use-react-flow)
hook.

```tsx {1-2,7,10-15,20-21}
import { useMemo, useCallback } from 'react';
import ReactFlow, { NodeMouseHandler, useReactFlow, } from 'reactflow';
...

export default function App() {
  const start = '01'
  const { fitView } = useReactFlow();
  const { nodes, edges } = useMemo(() => slidesToElements(start, slides), []);

  const handleNodeClick = useCallback<NodeMouseHandler>(
    (_, node) => {
      fitView({ nodes: [node], duration: 150 });
    },
    [fitView],
  );

  return (
    <ReactFlow
      ...
      fitViewOptions={{ nodes: [{ id: start }] }}
      onNodeClick={handleNodeClick}
    />
  );
}
```

In the code above, we've added a `handleNodeClick` callback that pans and zooms
the canvas to focus on the clicked node. This works because the `fitView` function
accepts an array of nodes to focus on, and a duration to transition to the new
viewport. All the options for `fitView` can be found documented under the
[`FitViewOptions`](/api-reference/types/fit-view-options) type.

We're also passing some options for the initial fit view of the flow itself. This
will mean the start slide is always in view when the app is first loaded.

<Bleed>
  <BlogExampleViewer
    style={{ aspectRatio: '16 / 9' }}
    codePath="blog-flows/presentation/FocusOnClick"
    additionalFiles={[ 'Slide.tsx', 'slides.ts', 'index.css']}
    dependencies={{ 'react-remark': '2.1.0' }}
    showEditor={false}
    isTypescript
  />
</Bleed>

### Slide controls

... words

Let's add a `<footer>` to each slide that conditionally renders a button in any
direction with a connected slide. We'll also preemtively create a `moveToNextSlide`
callback that we'll implement in a second.

```tsx {3,8,13-18}
import { type NodeProps } from 'reactflow';
import { Remark } from 'react-remark';
import { useCallback } from 'react';

export function Slide({ data }: NodeProps<SlideData>) {
  ...

  const moveToNextSlide = useCallback((id: string) => {}, [])

  return (
    <article className="slide nodrag" style={style}>
      <Remark>{source}</Remark>
      <footer className="slide__controls nopan">
        {data.left && <button onClick={() => moveToNextSlide(data.left)}>←</button>}
        {data.up && <button onClick={() => moveToNextSlide(data.up)}>↑</button>}
        {data.down && <button onClick={() => moveToNextSlide(ddata.own)}>↓</button>}
        {data.right && <button onClick={() => moveToNextSlide(data.right)}>→</button>}
      </footer>
    </article>
  );
}
```

You can style the footer however you like, but it's important to add the `"nopan"`
class to prevent prevent the canvas from panning as you interact with any of the
buttons.

To implement the `moveToNextSlide` callback we can make use of the `fitView`
method on the [React Flow instance](/reference/types/react-flow-instance). to
access this, we need to pull in the `useReactFlow` hook:

```tsx {1}
import { type NodeProps, useReactFlow } from 'reactflow';
import { Remark } from 'react-remark';
import { useCallback } from 'react';

...
```

The `fitView` method can smoothly transition the viewport from one node to another
by passing in an array of node ids to focus on, which is exactly the behaviour
we want for our presentation!

```tsx {2, 4-9}
export function Slide({ data }: NodeProps<SlideData>) {
  const { fitView } = useReactFlow();

  const moveToNextSlide = useCallback(
    (id: string) => {
      fitView({ nodes: [{ id }], duration: 150 });
    },
    [fitView],
  );

  return (
    <article className="slide" style={style}>
      ...
    </article>
  );
}
```

But what about keyboard navigation?

### Keyboard navigation

In addition to `onNodeClick`, we can also listen to _keyboard events_ on the
`<ReactFlow />` component through handlers like [`onKeyDown`](/api-reference/react-flow#on-key-down).

Up until now the slide currently focused is implied by the position of the canvas,
but if we want to handle key presses on the entire canvas we need to _explicitly_
track the current slide. In our main `<App />` component we'll add a piece of
state to track the current slide id, and initialise it with the start slide.

</TutorialLayout>
